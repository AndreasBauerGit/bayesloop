#!/usr/bin/env python
"""
This file introduces an extension to the basic Study-class that allows to compute the distribution of hyper-paraeters.
"""

import numpy as np
from .study import Study
from .preprocessing import *


class RasterStudy(Study):
    """

    """
    def __init__(self):
        super(RasterStudy, self).__init__()

        self.raster = []
        self.rasterValues = []
        self.rasterConstant = []
        self.hyperParameterPrior = None
        self.hyperParameterDistribution = None
        self.averagePosteriorSequence = None

        print '  --> Raster study'

    def fit(self, raster=[], silent=False):
        """
        This method over-rides the according method of the Study-class. It runs the algorithm for equally spaced hyper-
        parameter values as defined by the variable rasterDictionary. The posterior sequence represents the average
        model of all analyses. Posterior mean values are computed from this average model.

        Parameters:
            rasterDistionary - dictionary containing the names of hyper-parameters and tuple with lower and upper
                               boundary as well as stepsize.
            silent - If set to True, no output is generated by the fitting method.

        Returns:
            None
        """
        if not silent:
            print '+ Started new fit.'

        # create array with raster-values
        temp = np.meshgrid(*[np.linspace(lower, upper, steps) for name, lower, upper, steps in raster])
        self.rasterValues = np.array([t.flatten() for t in temp]).T
        self.rasterConstant = [np.abs(upper-lower)/(float(steps)-1) for name, lower, upper, steps in raster]

        # prepare arrays for change-point distribution and average posterior sequence
        self.formattedData = movingWindow(self.rawData, self.observationModel.segmentLength)
        if self.hyperParameterPrior is None:
            self.hyperParameterPrior = np.ones(len(self.rasterValues))/len(self.rasterValues)
        else:
            # check if given prior is correctly formatted to fit length of raster array
            if len(self.hyperParameterPrior) != len(self.rasterValues):
                print '! Given raster expects {0} values for hyper-parameter prior.'.format(len(self.rasterValues))
                return

        self.averagePosteriorSequence = np.zeros([len(self.formattedData)]+self.gridSize)
        logEvidenceList = []
        localEvidenceList = []

        for i, hyperParamValues in enumerate(self.rasterValues):
            # we use the setHyperParameters-method from the Study class
            self.parametersToOptimize = [name for name, lower, upper, steps in raster]
            self.setHyperParameters(hyperParamValues)

            # call fit method from parent class
            Study.fit(self, silent=True)

            logEvidenceList.append(self.logEvidence)
            localEvidenceList.append(self.localEvidence)
            self.averagePosteriorSequence += self.posteriorSequence*np.exp(self.logEvidence)*self.hyperParameterPrior[i]

            if not silent:
                print '    + Raster point {} of {} -- Hyper-parameter values {} -- log10-evidence = {:.5f}'\
                    .format(i, len(self.rasterValues), hyperParamValues, self.logEvidence / np.log(10))

        # compute average posterior distribution
        normalization = np.array([np.sum(posterior) for posterior in self.averagePosteriorSequence])
        self.averagePosteriorSequence /= normalization[:,None]

        # set self.posteriorSequence to average posterior sequence for plotting reasons
        self.posteriorSequence = self.averagePosteriorSequence

        if not silent:
            print '    + Computed average posterior sequence'

        # compute log-evidence of average model
        self.logEvidence = np.log(np.sum(np.exp(np.array(logEvidenceList))*self.hyperParameterPrior))

        if not silent:
            print '    + Log10-evidence of average model: {:.5f}'.format(self.logEvidence / np.log(10))

        # compute hyper-parameter distribution
        self.hyperParameterDistribution = np.exp(np.array(logEvidenceList))*self.hyperParameterPrior
        self.hyperParameterDistribution /= np.sum(self.hyperParameterDistribution)
        self.hyperParameterDistribution /= np.prod(self.rasterConstant)  # probability density

        if not silent:
            print '    + Computed hyper-parameter distribution'

        # compute local evidence of average model
        self.localEvidence = np.sum((np.array(localEvidenceList).T*self.hyperParameterDistribution).T, axis=0)

        if not silent:
            print '    + Computed local evidence of average model'

        # compute posterior mean values
        self.posteriorMeanValues = np.empty([len(self.grid), len(self.posteriorSequence)])
        for i in range(len(self.grid)):
            self.posteriorMeanValues[i] = np.array([np.sum(p*self.grid[i]) for p in self.posteriorSequence])

        if not silent:
            print '    + Computed mean parameter values.'

    # optimization methods are inherited from Study class, but cannot be used in this case
    def optimize(self):
        raise AttributeError( "'changepointStudy' object has no attribute 'optimize'" )

    def optimizationStep(self):
        raise AttributeError( "'changepointStudy' object has no attribute 'optimizationStep'" )


